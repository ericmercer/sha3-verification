\section{Amended Cryptol}
\label{sec:amended}
Initially it appeared that visual inspection with Cryptol’s standard syntax was subpar.
The language's functional folds and list comprehensions do not align easily with the imperative 
and array-based NIST standard. By leveraging Cryptol’s versatility, however, we produced a couple 
utility functions to visually mimic the sequential nature of the NIST specification. 

The phrase “for all” indicates a looping structure and is quite common in the NIST standard. 
It is used in the definition of the pi function.

\begin{figure}[h]
  \centering
  \begin{verbatim}
1. For all triples (x,y,z) such that 
  0 <= x < 5, 0 <= y < 5, and 0 <= z < w,
  let A'[x, y, z] = A[(x + 3y) mod 5, x, z].
2. Return A'.
  \end{verbatim}
  \caption{NIST Pi definition}
  \label{fig:nistPi}
\end{figure}
    
Using Cryptol's list comprehensions, we find the following syntax for the pi function:

\begin{figure}[h]
  \centering
\begin{verbatim}
type COL = 5 
type W = 64
type STATE_ARR = [COL][COL][W]
LIST4 = [0..COL-1]
LIST63 = [0..W-1]
pi : STATE_ARR -> STATE_ARR
pi a = [[[a @x @((x + 3y) % COL) @z 
            | z <- LIST63] 
          | y <- LIST4] 
        | x <- LIST4]
\end{verbatim}
\caption{Cryptol Pi definition}
\label{fig:cryptolPi}
\end{figure}

Cryptol declares list comprehension variables after they are used, and the order of the
nested loops is not as apparent. Using a helper function, ‘for’, we were able to provide
the following syntax:

\begin{figure}[h]
  \centering
\begin{verbatim}
type COL = 5 
type W = 64
type STATE_ARR = [COL][COL][W]
LIST4 = [0..COL-1]
LIST63 = [0..W-1]
pi : STATE_ARR -> STATE_ARR
pi a = for LIST4 (\x ->
          for LIST4 (\y -> 
            for LIST4 (\z -> 
              a @x @((x + 3*y) % `COL) @z)))
\end{verbatim}
\caption{Amended Cryptol Pi definition}
\label{fig:cryptolAmendedPi}
\end{figure}

The ‘for’ utility function follows the same intuition as the implementation in most 
imperative languages in that it iterates and runs a loop body over defined elements. 
It is similar to the Array.prototype.map method in JavaScript in that it takes in a 
function and a list of arguments and returns a list of results from calling the function 
on every element of the input array. It is implemented as so:

\begin{figure}[h]
  \centering
\begin{verbatim}
for : {n, a, b} [n]a -> (a -> b) -> [n]b
for vals loop = [loop index | index <- vals]
\end{verbatim}
\caption{Cryptol For utility function}
\label{fig:cryptolFor}
\end{figure}

While simple to implement, it reorders and structures the arguments in a very elegant way.
In constrast with standard cryptol syntax, the list to iterate over and the iterating 
variable are visible before the loop body. List comprehensions are hidden away behind this 
function call and visual equivalence is clearer.

Another common phrasing is the “let...for...let”. This defines a state upon which a folding 
occurs, which is most comparable to a while loop. Here is the rc function as defined in the 
NIST spec:

\begin{figure}[h]
  \centering
\begin{verbatim}
1. If t mod 255 = 0, return 1.
2. Let R = 10000000.
3. For i from 1 to t mod 255, let:
  a. R = 0 || R;
  b. R[0] = R[0] ^ R[8];
  c. R[4] = R[4] ^ R[8];
  d. R[5] = R[5] ^ R[8];
  e. R[6] = R[6] ^ R[8];
  f. R =Trunc8[R].
4. Return R[0].
\end{verbatim}
\caption{NIST RC definition}
\label{fig:nistRC}
\end{figure}

Cryptol list comprehensions require a list to iterate over. Our ‘for’ utility function does 
as well. Knowing that the number of iterations is bounded by [1, 254], we can construct the 
following ungainly Cryptol definition:

\begin{figure}[h]
  \centering
\begin{verbatim}
rc : [64] -> Bit
rc t = if (t % 255) == 0 
  then True 
  else rs !0 @0 where
    rs = [128:[8]] # [
      if i <= t % 255
        then (take`{8} ([
          (r@0) ^ (r@8),
          r@1,
          r@2,
          r@3, 
          (r@4) ^ (r@8),
          (r@5) ^ (r@8),
          (r@6) ^ (r@8),
          r@7,
          r@8])
            where r = [False] # (rs @(i - 1)))
        else rs @(i - 1)
      | i <- [1..254]]
\end{verbatim}
\caption{Cryptol RC definition}
\label{fig:cryptolRC}
\end{figure}

Not only is this computationally slower since it runs 255 loops every time rc is called, 
is stores the previous states in a list and indexes into it. This differs vastly from the 
NIST specificiation both visually and functionally. Using a new ‘while’ utility function, we 
can declare an initial state, condition function, and body function that will recursively 
be called until the condition is met. It consolodates the information of the previous state 
until the condition is sastified. Here is the rc function with the use of this utility 
function:

\begin{figure}[h]
  \centering
\begin{verbatim}
rc : [64] -> Bit
rc t = if (t % 255) == 0 
  then True 
  else (while {i = 1, R = 128:[8]} //STATE
    (\state -> state.i <= t % 255) //COND
    (\state -> {                   //LOOP
      i = state.i + 1, 
      R = (take`{8} ([
        (r@0) ^ (r@8),
        r@1,
        r@2,
        r@3,
        (r@4) ^ (r@8),
        (r@5) ^ (r@8),
        (r@6) ^ (r@8),
        r@7, 
        r@8]) 
          where r = [False] # state.R)})
    ).R @0
\end{verbatim}
\caption{Amended Cryptol RC definition}
\label{fig:cryptolamendedRC}
\end{figure}

The final state is returned by the ‘while’ function. This iterates only until the 
condition is met, avoids the clutter of indexing within a larger array of all previous 
states, and places the condition in a more obvious location before the loop body. Here 
is the definition of the ‘while’ utility function:

\begin{figure}[h]
  \centering
\begin{verbatim}
while : {a} a -> (a -> Bit) -> (a -> a) -> a
while state cond f = if (cond state)
  then (while (f state) cond f)	
  else state
\end{verbatim}
\caption{Cryptol While utility function}
\label{fig:cryptolWhile}
\end{figure}