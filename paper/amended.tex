\section{Amended Cryptol}\label{sec:amended}
TODO:

Imperative spec, functional language, Cryptol's looping syntax can be cryptic.

Rational and descriptions of utility functions, examples of utility functions.

for-each == javascript map, while loop == javascript reduce.

Initially it appeared that visual inspection with Cryptol’s standard syntax was subpar.
Cryptol’s functional folds and list comprehensions do not align easily with the imperative 
and array-based NIST standard. BY leveraging Cryptol’s versatility, however, we produced a couple 
utility functions to visually mimic the sequential nature of the specification. 

The phrase “for all” is quite common in the NIST document, and it implies a looping structure. 
The following is the NIST definition of the pi function:
\begin{verbatim}
  1. For all triples (x,y,z) such that 
    0 <= x < 5, 0 <= y < 5, and 0 <= z < w,
    let A'[x, y, z] = A[(x + 3y) mod 5, x, z].
  2. Return A'.
\end{verbatim}
    
Using Cryptol's list comprehensions, we find the following syntax for the pi function:
\begin{verbatim}
  type COL = 5 
  type W = 64
  LIST4 = [0..COL-1]
  LIST63 = [0..W-1]
  type STATE_ARR = [COL][COL][W]
  pi : STATE_ARR -> STATE_ARR
  pi a = [[[a @x @((x + 3y) % COL) @z 
             | z <- LIST63] 
           | y <- LIST4] 
         | x <- LIST4]
\end{verbatim}

Cryptol declares list comprehension variables after they are used, and the order of the
nested loops is not as apparent. Using a helper function, ‘for’, we were able to provide
the following syntax:

\begin{verbatim}
  type COL = 5 
  type W = 64
  type STATE_ARR = [COL][COL][W]
  LIST4 = [0..COL-1]
  LIST63 = [0..W-1]
  pi : STATE_ARR -> STATE_ARR
  pi a = for LIST4 (\y ->
           for LIST4 (\x -> 
             for LIST4 (\z -> 
               a @x @((x + 3*y) % `COL) @z)))
\end{verbatim}

  The ‘for’ utility function follows the same intuition as the implementation in most 
  imperative languages. That is, it iterates over the list provided. It is similar to the 
  Array.prototype.map method in JavaScript in that it takes in a function and a list of 
  arguments and returns a list of results from calling the function on every element of the 
  input array. It is implemented as so:

\begin{verbatim}
  for : {n, a, b} [n]a -> (a -> b) -> [n]b
  for vals loop = [loop index | index <- vals]
\end{verbatim}

While simple to implement, it reorders and structures the arguments in a very elegant way.
In constrast with standard cryptol syntax, the list to iterate over and the iterating 
variable are visible before the loop body. List comprehensions are hidden away behind this 
function call and visual equivalence is clearer.

Another common phrasing is the “let...for...let”. This defines a state upon which a folding 
occurs, which is most comparable to a while loop. Here is the rc function as defined in the 
NIST spec:

\begin{verbatim}
  1. If t mod 255 = 0, return 1.
  2. Let R = 10000000.
  3. For i from 1 to t mod 255, let:
    a. R = 0 || R;
    b. R[0] = R[0] ^ R[8];
    c. R[4] = R[4] ^ R[8];
    d. R[5] = R[5] ^ R[8];
    e. R[6] = R[6] ^ R[8];
    f. R =Trunc8[R].
  4. Return R[0].
\end{verbatim}

Cryptol list comprehensions require a list to iterate over. Our ‘for’ utility function does 
as well. Knowing that the number of iterations is bounded by [1, 254], we can construct the 
following ungainly Cryptol definition:

\begin{verbatim}
  rc : [64] -> Bit
  rc t = if (t % 255) == 0 
    then True 
      else (rList !0).R @0 where
        rList = [{i = 1, R = 128:[8]}] # [{
          i = r @i + 1, 
          R = if i <= t % 255
            then (take`{8} ([
              (r@0)^(r@8),
              r@1,
              r@2,
              r@3, 
              (r@4)^(r@8),
              (r@5)^(r@8),
              (r@6)^(r@8),
              r@7,
              r@8])
                where r = [False] # state.R)
            else (rList @i).R}
          | i <- [0..254]]
\end{verbatim}

Not only is this computationally slower since it runs 255 loops every time rc is called,
it differs vastly from the NIST specificiation. Using a new ‘while’ utility function, we 
can declare an initial state, condition function, and body function that will recursively 
be called until the condition is met. Here is the rc function with the use of this utility 
function:

\begin{verbatim}
  rc : [64] -> Bit
  rc t = if (t % 255) == 0 
    then True 
    else (while {i = 1, R = 128:[8]} //STATE
      (\state -> state.i <= t % 255) //COND
      (\state -> {                   //LOOP
        i = state.i + 1, 
        R = (take`{8} ([
          (r@0)^(r@8),
          r@1,
          r@2,
          r@3,
          (r@4)^(r@8),
          (r@5)^(r@8),
          (r@6)^(r@8),
          r@7, 
          r@8]) 
            where r = [False] # state.R)})
      ).R @0
\end{verbatim}

The final state is returned by the ‘while’ function. This iterates only until the 
condition is met, avoids the clutter of indexing within a larger array of all previous 
states, and places the condition in a more obvious location before the loop body. Here 
is the definition of the ‘while’ utility function:

\begin{verbatim}
  while : {a} a -> (a -> Bit) -> (a -> a) -> a
  while state cond f = if (cond state)
    then (while (f state) cond f)	
    else state
\end{verbatim}

While the condition is not met by the current state, continue to iterate. Else, return the 
current state.
