This section illustrates with a few examples how the \fips\ specification is captured in \cryptol. 
\cryptol's functional folds and list comprehensions do not directly align with the quantification and iteration in the specification. 
This misalignment made the \cryptol\ specification difficult to read and to manually argue its equivalence relative to the published specification.
The two specifications are realigned through a library of methods in \cryptol\ that hide the functional folds and list comprehensions so that the \cryptol\ specification reads more like the \fips\ specification. The two most common library methods are the \emph{for-method} and the \emph{while-method} discussed in this section.

\subsection{The for-method}

\newsavebox{\fipsPi}
\begin{lrbox}{\fipsPi}
  \begin{lstlisting}[basewidth = {.5em},basicstyle={\small}]
    1. For all triples (x,y,z) such that 
           0 <= x < 5, 0 <= y < 5, and 0 <= z < w,
       let A'[x, y, z] = A[(x + 3y) mod 5, x, z].
    2. Return A'.
  \end{lstlisting}
\end{lrbox}

\newsavebox{\PiCry}
\begin{lrbox}{\PiCry}
  \begin{lstlisting}[language=Cryptol, numbers=left, escapeinside={;}{;}]
    type STATE_ARR = [5][5][64];\label{line:state};
    LIST4 = [0..4];\label{line:list4};
    LIST63 = [0..63];\label{line:list63};
    pi : STATE_ARR -> STATE_ARR
    pi a = [  [  [a @x @((x + 3*y) % 5) @z;\label{line:pi};
                 | z <- LIST63] 
              | y <- LIST4] 
           | x <- LIST4]
  \end{lstlisting}
\end{lrbox}

\newsavebox{\PiCryLib}
\begin{lrbox}{\PiCryLib}
  \begin{lstlisting}[language=Cryptol]
    pi a = for LIST4 (&x ->
             for LIST4 (&y -> 
               for LIST63 (&z -> 
                 a @x @((x + 3*y) % 5) @z)))
  \end{lstlisting}
\end{lrbox}

\newsavebox{\formethod}
\begin{lrbox}{\formethod}
  \begin{lstlisting}[language=Cryptol]
    for : {n, a, b} [n]a -> (a -> b) -> [n]b
    for vals f = [f i | i <- vals]
  \end{lstlisting}
\end{lrbox}

\begin{figure}[t]
  \begin{center}
    \begin{tabular}{l}
      \usebox{\fipsPi} \\ \\
      \multicolumn{1}{c}{(a)} \\ \\
      \usebox{\PiCry} \\ \\
      \multicolumn{1}{c}{(b)} \\ \\
      \usebox{\formethod} \\ \\
      \multicolumn{1}{c}{(d)} \\ \\ 
      \usebox{\PiCryLib} \\ \\
      \multicolumn{1}{c}{(c)}
    \end{tabular}
  \end{center}
  \caption{The $\pi$ function. (a) The \fips\ specification. (b) The \cryptol\ with comprehensions. (c) The for-method definition. (d) The \cryptol\ with the for-method.}
  \label{fig:pi}
\end{figure}

A common idiom in the \fips\ publication is using quantification over a finite domain defined by linear constraints to define input for some computation.
The definition of the $\pi$ function for \keccak\ shown in \figref{fig:pi}(a) is one such example.
Here the quantification is used to define the set of indices that are part of the $\pi$ computation that transforms the state array. The intent is that of a \emph{parallel-for} where order does not matter since the new state array $A^\prime$ only depends on the old state array $A$.

The \cryptol\ definition using list comprehensions is given in \figref{fig:pi}(b).
\lineref{line:state}) defines the state as a $5 \times 5$ array of 64-bit words.
\lineref{line:list4} and \lineref{line:list63} are the lists for the list comprehensions.
These are the indices that are used in the computation and correspond to the finite domains for $x$, $y$, and $z$ defined in the quantification in \figref{fig:pi}(a).
\lineref{line:pi} starts the definition of $\pi$. 
Here the comprehensions are nested with the list indices appearing in reverse order to follow the nesting.
Although the list comprehensions are not unreadable, the \cryptol\ can be improved by creating a for-method to hide some of the details.

\figref{fig:pi}(c) is the \cryptol\ definition of the for-method.
It takes two arguments: a list, \emph{vals}, for the comprehension, and a function, $f$, to apply to each element of the list.
Its definition is as expected: it applies $f$ to each element in \emph{vals}.

\figref{fig:pi}(d) is the rewritten \cryptol\ using the for-method.
It still requires the indices lists for the comprehension, but it has a more obvious correspondence to the original definition in \figref{fig:pi}(a).
The for-method reorders and structures the arguments in a very elegant way.
It hides the list comprehensions to simplify the task of visual inspection for equivalence.

\subsection{The while-method}
Another common phrasing is the \emph{let...for...let}. 
This defines a state upon which a folding occurs, iteratively condensing the information into a final state. 
Imperatively, it is most comparable to a while loop. 
As shown by Figure \ref{fig:nistRC}, is present in the rc function defined by the NIST specification.

\begin{figure}[h]
  \centering
\begin{lstlisting}[basewidth = {.5em},basicstyle={\scriptsize}]
1. If t mod 255 = 0, return 1.
2. Let R = 10000000.
3. For i from 1 to t mod 255, let:
  a. R = 0 || R;
  b. R[0] = R[0] ^ R[8];
  c. R[4] = R[4] ^ R[8];
  d. R[5] = R[5] ^ R[8];
  e. R[6] = R[6] ^ R[8];
  f. R = Trunc8[R].
4. Return R[0].
\end{lstlisting}
\caption{NIST RC definition}
\label{fig:nistRC}
\end{figure}

Maintaining this state through Cryptol's list comprehensions can be difficult.
The comprehensions require a list to iterate through. 
Since the \emph{for} utility function is simply a wrapper for list comprehensions, it is equally unsuited for visual verification on such steps. 
The number of iterations in the RC function is bounded by [1, 254] by its modular condition.
This range provides the list to iterate over as required by Cryptol list comprehensions. 
From these observations, a rather ungainly Cryptol definition results.
This definition is shown in Figure \ref{fig:cryptolRC}.

\begin{figure}[h]
  \centering
\begin{lstlisting}[language=Cryptol]
rc : [64] -> Bit
rc t = if (t % 255) == 0 
  then True 
  else rs !0 @0 where
    rs = [128:[8]] # [
      if i <= t % 255
        then (take'{8} ([
          (r@0) ^ (r@8),
          r@1,
          r@2,
          r@3, 
          (r@4) ^ (r@8),
          (r@5) ^ (r@8),
          (r@6) ^ (r@8),
          r@7,
          r@8])
            where r = [False] # (rs @(i - 1)))
        else rs @(i - 1)
      | i <- [1..254]]
\end{lstlisting}
\caption{Cryptol RC definition}
\label{fig:cryptolRC}
\end{figure}

Not only is this definition computationally slower as it runs 255 loops every time it is called, it also awkwardly indexes into a list of previous states. 
This differs vastly from the NIST specificiation both visually and functionally. 
The \emph{while} utility function, accepts an initial state, condition function, and body function to recursively loop. 
It consolodates the information of the previous state until the condition is sastified. 
This definition is found in Figure \ref{fig:cryptolamendedRC}.

\begin{figure}[h]
  \centering
\begin{lstlisting}[language=Cryptol]
rc : [64] -> Bit
rc t = if (t % 255) == 0 
  then True 
  else (while {i = 1, R = 128:[8]}
    (&state -> state.i <= t % 255)
    (&state -> {
      i = state.i + 1, 
      R = (take'{8} ([
        (r@0) ^ (r@8),
        r@1,
        r@2,
        r@3,
        (r@4) ^ (r@8),
        (r@5) ^ (r@8),
        (r@6) ^ (r@8),
        r@7, 
        r@8]) 
          where r = [False] # state.R)})
    ).R @0
\end{lstlisting}
\caption{Amended Cryptol RC definition}
\label{fig:cryptolamendedRC}
\end{figure}

The final state is returned by the \emph{while} function. 
This iterates only until the condition is met, avoids the clutter of indexing within a larger array of all previous states, and places the condition in a more obvious location before the loop body. 
This utility function is defined in Figure \ref{fig:cryptolWhile}.

\begin{figure}[h]
  \centering
\begin{lstlisting}[language=Cryptol]
while : {a} a -> (a -> Bit) -> (a -> a) -> a
while state cond f = if (cond state)
  then (while (f state) cond f)	
  else state
\end{lstlisting}
\caption{Cryptol While utility function}
\label{fig:cryptolWhile}
\end{figure}