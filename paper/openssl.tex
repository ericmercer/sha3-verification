\section{SHA3 OpenSSL in Cryptol}\label{sec:openssl}
Even with the highly modular approach of the SHA3 algorithm, a direct proof from the Cryptol specification that matched the NIST standard and the OpenSSL source code was unviable.
OpenSSL's source code is often used in low-level software, and it is often optimized to improve performance and viability for embedded systems.
One major instance of such optimization proved significant enough to prevent a direct proof from the NIST Cryptol specification to OpenSSL.

\lstset{style=customc, firstnumber=177}
\begin{figure}[h]
  \centering
\begin{lstlisting}
  void Iota(uint64_t A[5][5], size_t i)
  {
    //assert(i < (sizeof(iotas) / sizeof(iotas[0])));
    if (i < (sizeof(iotas) / sizeof(iotas[0]))) {
      A[0][0] ^= iotas[i];
    }
  }
\end{lstlisting}
\caption{OpenSSL's Iota Function}
\label{fig:cIota}
\end{figure}

As per the NIST specification, the Iota function invokes the rc algorithm to generate a constant value specific to the round count to use in exclusive-or operations.
The rc function inputs are unrelated to the message to be hashed, which means that for any given message, the iteration through the rounds of keccak will produce the same constant values.
Because these values are unchanged from run to run, OpenSSL's optimized implementation of keccak stores the output values as a constant table and use the current round number to properly index into it as is shown in Figure \ref{fig:cIota}. 
Initially, the Cryptol code followed the NIST standard as closely as possible\textemdash including rc method calls in the Iota function which computed the values every iteration.
Attempts to prove out such a specification to the OpenSSL code failed however, because SAW was unable to show the computational equivalence between computing values as needed and looking up values in a constant table.

\begin{figure}[h]
  \centering
\begin{lstlisting}[language=Cryptol]
  iota : STATE_ARR -> [64] -> STATE_ARR
  iota a i = for LIST4 (\y ->
                for LIST4 (\x ->
                    for LIST63 (\z ->
                        if ((x == 0) && (y == 0))
                            then (a @0 @0 @z) ^ (LISTIOTAS @i @z)
	                        else a @y @x @z)))

  LISTIOTAS = [reverse (
        (while {RC = 0:[W], j = 0} //STATE
            (\state -> state.j <= `L) //COND
            (\state -> { //LOOP
                RC = for LIST63 (\z ->
                    if z == index
                        then rc (state.j + 7*i)
                        else state.RC @z)
                    where index = ((1:[8]) << state.j) - 1,
                j = state.j + 1})
        ).RC) | i <- LISTROUNDS:[_][64]]

  rc : [64] -> Bit
  rc t = if (t % 255) == 0 
	  then True 
	  else (while {i = 1, R = 128:[8]} //STATE
		  (\state -> state.i <= t % 255) //COND
		  (\state -> { //LOOP
			  i = state.i + 1, 
			  R = (take`{8} ([(r@0)^(r@8), r@1, r@2, r@3, (r@4)^(r@8), (r@5)^(r@8), (r@6)^(r@8), r@7, r@8]) 
				  where r = [False] # state.R)
		    })
		).R @0
\end{lstlisting}
\caption{OpenSSL's Iota Function}
\label{fig:cryptolIota}
\end{figure}

The lack of any meaningful trace of computation that comes with pre-computed values, meant that a different approach would be necessary to meet in the middle.
The solution was to modify the Cryptol specification to also use a lookup table in the Iota function.
However, the Cryptol code still uses the rc function to generate that lookup table at the beginning of every run of SHA3, rather than strictly stating constant values in the code.
By having both the Cryptol and C Iota functions now rely on looking up values in a table, the task of proving them became far simpler.
SAW only had to show that the table generated by running the rc function all at once at the beginning, was identical to the one hard coded into OpenSSL's implementation.
Because those match, and both implementations index into the table in the same way, SAW was able to generate the proof.

This approach recognizably added an extra element to the visual inspection between the Cryptol specification and the C code.
The full rc computation is still used in the Cryptol code, with the only significant difference being that rather than run rc every time Iota is called, rc is run all at once to generate all the needed values.
The continued inclusion of the rc computation makes it only a much less significant inconvenience to accept the computed table as accurate. 
It likewise remains simple to see visually that indexing into the table gives back the proper constant value for a given round count.

As a note, one minor adjustment was also made to OpenSSL's Iota function code to allow the proof to complete properly.
As an error check, OpenSSL uses an assert to ensure that the round count is never greater than it should be (to ensure no indexing out of the array's bounds).
SAW cannot recognize an assert statement in its symbolic execution engine.
As a result, that statement was removed and replaced with a comparable if statement which maintained the logic of the function.
Because the equivalence proof for the Iota function is run with the precondition that the round count must be less than 24 (max rounds), this does not affect the comparison between the C code and the Cryptol code (which does not have that error check).