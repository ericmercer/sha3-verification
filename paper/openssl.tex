Even with the highly modular approach of the SHA3 algorithm, a direct proof from the Cryptol specification that matched the NIST standard and the OpenSSL source code was unviable.
OpenSSL's source code is often used in low-level software, and it is often optimized to improve performance and viability for embedded systems.
One major instance of such optimization proved significant enough to prevent a direct proof from the NIST Cryptol specification to OpenSSL.

\lstset{style=customc, firstnumber=177}
\begin{figure}[h]
  \centering
\begin{lstlisting}
  void Iota(uint64_t A[5][5], size_t i)
  {
    //assert(i < (sizeof(iotas) / sizeof(iotas[0])));
    if (i < (sizeof(iotas) / sizeof(iotas[0]))) {
      A[0][0] ^= iotas[i];
    }
  }
\end{lstlisting}
\caption{OpenSSL's Iota Function}
\label{fig:cIota}
\end{figure}

As per the NIST specification, the Iota function invokes the rc algorithm to generate a constant value specific to the round count to use in exclusive-or operations.
The rc function inputs are unrelated to the message to be hashed, which means that for any given message, the iteration through the rounds of keccak will produce the same constant values.
Because these values are unchanged from run to run, OpenSSL's optimized implementation of keccak stores the output values as a constant table and use the current round number to properly index into it as is shown in Figure \ref{fig:cIota}. 
Initially, the Cryptol code followed the NIST standard as closely as possible\textemdash including rc method calls in the Iota function which computed the values every iteration.
Attempts to prove out such a specification to the OpenSSL code failed however, because SAW was unable to show the computational equivalence between computing values as needed and looking up values in a constant table.

\begin{figure}[h]
  \centering
\begin{lstlisting}[language=Cryptol]
  iota : STATE_ARR -> [64] -> STATE_ARR
  iota a i = for LIST4 (\y ->
                for LIST4 (\x ->
                    for LIST63 (\z ->
                        if ((x == 0) && (y == 0))
                            then (a @0 @0 @z) ^ (LISTIOTAS @i @z)
	                        else a @y @x @z)))

  LISTIOTAS = [reverse (
        (while {RC = 0:[W], j = 0} //STATE
            (\state -> state.j <= `L) //COND
            (\state -> { //LOOP
                RC = for LIST63 (\z ->
                    if z == index
                        then rc (state.j + 7*i)
                        else state.RC @z)
                    where index = ((1:[8]) << state.j) - 1,
                j = state.j + 1})
        ).RC) | i <- LISTROUNDS:[_][64]]
\end{lstlisting}
\caption{OpenSSL's Iota Function}
\label{fig:cryptolIota}
\end{figure}

The lack of any meaningful trace of computation that comes with pre-computed values, meant that a different approach would be necessary to meet in the middle.
The solution was to modify the Cryptol specification to also use a lookup table in the Iota function.
However, the Cryptol code still uses the rc function as defined in Figure \ref{fig:nistRC} to generate that lookup table at the beginning of every run of SHA3, rather than strictly stating constant values in the code.
By having both the Cryptol and C Iota functions now rely on looking up values in a table, the task of proving them became far simpler.
SAW only had to show that the table generated by running the rc function all at once at the beginning, was identical to the one hard coded into OpenSSL's implementation.
Because those match, and both implementations index into the table in the same way, SAW was able to generate the proof.

This approach recognizably added an extra element to the visual inspection between the Cryptol specification and the C code.
The full rc computation is still used in the Cryptol code, with the only significant difference being that rather than run rc every time Iota is called, rc is run all at once to generate all the needed values.
The continued inclusion of the rc computation makes it only a much less significant inconvenience to accept the computed table as accurate. 
It likewise remains simple to see visually that indexing into the table gives back the proper constant value for a given round count.

As a note, one minor adjustment was also made to OpenSSL's Iota function code to allow the proof to complete properly.
As an error check, OpenSSL uses an assert to ensure that the round count is never greater than it should be (to ensure no indexing out of the array's bounds).
SAW cannot recognize an assert statement in its symbolic execution engine.
As a result, that statement was removed and replaced with a comparable if statement which maintained the logic of the function.
Because the equivalence proof for the Iota function is run with the precondition that the round count must be less than 24 (max rounds), this does not affect the comparison between the C code and the Cryptol code (which does not have that error check).

A second obstacle that blocked a single direct proof is how OpenSSL stores and accesses its state array in memory.  
The NIST specification outlines the state array as being a 5 by 5 by w 3-dimensional array.
It denotes x as the horizontal axis, y as the vertical axis, and w as the z axis, like a cartesian coordinate system.
Because it structures the array this way, any access into the array \texttt{A[x, y, z]} is asking for the element at the x'th column, y'th row, z'th bit.
OpenSSL defines their state array as a \texttt{uint64\textunderscore t A[5][5]}.
As is common practice in many programming styles, their array indexes by row and then by column.
Because of this choice, an index defined by NIST as \texttt{A[x, y, z]} would in OpenSSL's array be indexed as \texttt{bit z of A[y][x]}.
In comparing C code to Cryptol, SAW relies on the pre and post state of memory for a given function to help determine functional equivalence.
The difference in memory storage/access choices by NIST and OpenSSL means that SAW cannot show functional equivalence using memory comparison.

OpenSSL's choice in memory storage yields another obstacle because of its array composition.
The way that bits are ordered and stored in a \texttt{uint64\textunderscore t} in C is strictly defined by the language's semantics.
Unfortunately, that bit ordering is reversed to the ordering NIST defines.
This yields yet another way that the memory differs and cannot be directly compared.

Between these two significant deviations by the OpenSSL implementation from the NIST standard, an intermediate step was necessary to complete a proof of equivalence.
The solution is a second Cryptol implementation that matches OpenSSL's code in these memory differences.
That second Cryptol code can be directly proven as equivalent to OpenSSL's code.

This leaves only the step of proving the two Cryptol specifications as equivalent.
Because of memory differences, this proof cannot be done on a low function level, as the OpenSSL proof is.
Instead, it must be done at the top level of the SHA algorithm so that the memory compared (input message and output hash) is identical in structure, notwithstanding the difference in state array implementation.
As SAW performs equivalence proofs based on defined static types, this proof can only be run on a specific input message size, and a specific output hash size.
To attain full coverage this proof must be run on all input message sizes that affect the way the code is executed.
This work determines the input set for full coverage to be all byte counts up to a full single block (200 Bytes), as this covers all padding and sponging operations performed in the creation of the state array.

This approach required significant computation time and resources and cannot be easily replicated, however the artifact repository coupled with this work provides receipts of the output generated by this proof.
However, with this step included a proof of functional equivalence between the visually reviewed Cryptol specification, and OpenSSL's Keccak function source code is complete.